---
// Simple live hero that renders the swirl WGSL shader onto a canvas using fragmentcolor WASM
---

<shader-hero style="display: block; margin: 5rem 0;">
  <canvas id="canvas"></canvas>
</shader-hero>

<script>
// @ts-nocheck
if (!customElements.get('shader-hero')) {
  class ShaderHero extends HTMLElement {
    /** @type {ShadowRoot} */ #shadow;
    /** @type {number} */ #raf = 0;
    /** @type {any} */ #renderer;
    /** @type {any} */ #target;
    /** @type {any} */ #shader;
    /** @type {any} */ #mod;
    #start = performance.now();
    #stopped = false;
    #ro = null;

    constructor() {
      super();
      this.#shadow = this.attachShadow({ mode: 'open' });
      this.#shadow.innerHTML = `
        <style>
          :host { display: block; margin: 1.5rem 0; }
          #canvas { width: 100%; height: 420px; background: #0f172a; border-radius: 8px; display: block; }
        </style>
        <canvas id=\"canvas\"></canvas>
      `;
    }

    connectedCallback() { this.#init(); }
    disconnectedCallback() { cancelAnimationFrame(this.#raf); try { this.#ro?.disconnect(); } catch {} }

    async #init() {
      const canvas = /** @type {HTMLCanvasElement} */ (this.#shadow.querySelector('#canvas'));
      if (!canvas) return;
      try {
        const mod = await import('fragmentcolor');
        this.#mod = mod;
        const wasmUrl = (await import('fragmentcolor/fragmentcolor_bg.wasm?url')).default;
        await mod.default({ module_or_path: wasmUrl });

        this.#renderer = new mod.Renderer();
        this.#target = await this.#renderer.createTarget(canvas);

        const qp = new URLSearchParams(location.search);
        this.#shader = qp.has('const') ? this.#mod.Shader.default() : await mod.Shader.fetch('/shaders/swirl.wgsl');

        try {
          this.#applySize();
          this.#shader.set('time', 0.0);
          const canvasEl = canvas;
          this.#ro = new ResizeObserver(() => this.#applySize());
          this.#ro.observe(canvasEl);
          window.addEventListener('resize', () => this.#applySize());
        } catch {}

        const loop = (now) => {
          if (this.#stopped) return;
          this.#raf = requestAnimationFrame(loop);
          this.#tick(now);
        };
        this.#raf = requestAnimationFrame(loop);
      } catch (e) {
        console.error('ShaderHero init failed', e);
      }
    }

    #tick(now) {
      if (!this.#renderer || !this.#target || !this.#shader) return;
      const canvas = /** @type {HTMLCanvasElement} */ (this.#shadow.querySelector('#canvas'));
      if (!canvas) return;

      const t = (now - this.#start) / 1000.0;
      try {
        this.#shader.set('time', t);
      } catch {
        // ignore
      }

      try {
        this.#renderer.render(this.#shader, this.#target);
      } catch (e) {
        if (!this.#stopped) {
          this.#stopped = true;
          try {
            const mlen = (this.#mod && this.#mod.memory && this.#mod.memory.buffer)
              ? this.#mod.memory.buffer.byteLength
              : 0;
            console.error('[hero] render failed (stopping loop)', e, { wasmMemBytes: mlen, stack: e?.stack });
          } catch {
            console.error('[hero] render failed (stopping loop)', e);
          }
          if (this.#raf) cancelAnimationFrame(this.#raf);
        }
        return;
      }
    }

    #applySize() {
      try {
        const canvas = /** @type {HTMLCanvasElement} */ (this.#shadow.querySelector('#canvas'));
        if (!canvas || !this.#target || !this.#shader) return;
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const w = Math.max(1, Math.floor(canvas.clientWidth * dpr));
        const h = Math.max(1, Math.floor(canvas.clientHeight * dpr));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w; canvas.height = h;
        }
        try { this.#target.resize([w, h]); } catch {}
        try { this.#shader.set('resolution', [w, h]); } catch {}
      } catch {}
    }
  }
  customElements.define('shader-hero', ShaderHero);
}
</script>
