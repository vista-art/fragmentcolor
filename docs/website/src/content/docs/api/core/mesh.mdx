---
title: Mesh
description: "High-level geometry container. A Mesh owns a list of vertices and optional instances. Internally it deduplicates vertices and always draws indexed and instanced (instance_count defaults to 1 when none are provided)."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

High-level geometry container. A Mesh owns a list of vertices and optional instances.
Internally it deduplicates vertices and always draws indexed and instanced
(instance_count defaults to 1 when none are provided).

Vertex layouts are managed by the Shader. At render time, inputs declared in your
shaderâs vertex function (annotated with @location(N)) are derived from the source
and matched by name and type to Mesh properties across both streams (instance first,
then vertex).

Mapping is driven by shader reflection; there are no special-case names or reserved locations.
The renderer matches attributes by explicit location if provided (instance first, then vertex),
and otherwise by name.

If a required input cannot be found or its type does not match, rendering returns an error
indicating the missing attribute or mismatch.



## Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::{Mesh, Vertex, VertexValue};

let mut mesh = Mesh::new();
mesh.add_vertex(Vertex::new([0.0, 0.5, 0.0]));
mesh.add_vertex(Vertex::new([-0.5, -0.5, 0.0]));
mesh.add_vertex(Vertex::new([0.5, -0.5, 0.0]));
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { {Mesh, Vertex, VertexValue} } from "fragmentcolor";

const mesh = new Mesh();
mesh.addVertex(Vertex.new([0.0, 0.5, 0.0]));
mesh.addVertex(Vertex.new([-0.5, -0.5, 0.0]));
mesh.addVertex(Vertex.new([0.5, -0.5, 0.0]));
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import {Mesh, Vertex, VertexValue}

mesh = Mesh()
mesh.add_vertex(Vertex.new([0.0, 0.5, 0.0]))
mesh.add_vertex(Vertex.new([-0.5, -0.5, 0.0]))
mesh.add_vertex(Vertex.new([0.5, -0.5, 0.0]))
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


## Methods


---

### Mesh::new

Create an empty mesh.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::Mesh;
let m = Mesh::new();
_ = m;
`}
lang="rust" meta="collapse={3-3}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Mesh } from "fragmentcolor";
const m = new Mesh();
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Mesh
m = Mesh()
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Mesh::from_vertices

Create a mesh from an iterator of Vertex values.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::{Mesh, Vertex};
let m = Mesh::from_vertices([
    Vertex::new([0.0, 0.0]),
    Vertex::new([1.0, 0.0]),
    Vertex::new([0.0, 1.0]),
]);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { {Mesh, Vertex} } from "fragmentcolor";
const m = Mesh.fromVertices([;
    Vertex.new([0.0, 0.0]),;
    Vertex.new([1.0, 0.0]),;
    Vertex.new([0.0, 1.0]),;
]);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import {Mesh, Vertex}
m = Mesh.from_vertices([
    Vertex.new([0.0, 0.0]),
    Vertex.new([1.0, 0.0]),
    Vertex.new([0.0, 1.0]),
])
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Mesh::add_vertex

Add a single vertex to the mesh.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::{Mesh, Vertex};
let mut m = Mesh::new();
m.add_vertex(Vertex::new([0.0, 0.0]));
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { {Mesh, Vertex} } from "fragmentcolor";
const m = new Mesh();
m.addVertex(Vertex.new([0.0, 0.0]));
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import {Mesh, Vertex}
m = Mesh()
m.add_vertex(Vertex.new([0.0, 0.0]))
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Mesh::add_vertices

Add many vertices to the mesh.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::{Mesh, Vertex};
let mut m = Mesh::new();
m.add_vertices([
  Vertex::new([0.0, 0.0]),
  Vertex::new([1.0, 0.0])
]);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { {Mesh, Vertex} } from "fragmentcolor";
const m = new Mesh();
m.addVertices([;
  Vertex.new([0.0, 0.0]),;
  Vertex.new([1.0, 0.0]);
]);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import {Mesh, Vertex}
m = Mesh()
m.add_vertices([
  Vertex.new([0.0, 0.0]),
  Vertex.new([1.0, 0.0])
])
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Mesh::add_instance

Add a single instance (any Vertex can be converted into an instance).

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::{Mesh, Vertex};
let mut m = Mesh::new();
let v = Vertex::new([0.0, 0.0]);
m.add_instance(v);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { {Mesh, Vertex} } from "fragmentcolor";
const m = new Mesh();
const v = new Vertex([0.0, 0.0]);
m.addInstance(v);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import {Mesh, Vertex}
m = Mesh()
v = Vertex([0.0, 0.0])
m.add_instance(v)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Mesh::add_instances

Add many instances to the mesh.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::{Mesh, Vertex};
let mut m = Mesh::new();
m.add_instances([
  Vertex::new([0.0, 0.0]),
  Vertex::new([1.0, 1.0]),
]);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { {Mesh, Vertex} } from "fragmentcolor";
const m = new Mesh();
m.addInstances([;
  Vertex.new([0.0, 0.0]),;
  Vertex.new([1.0, 1.0]),;
]);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import {Mesh, Vertex}
m = Mesh()
m.add_instances([
  Vertex.new([0.0, 0.0]),
  Vertex.new([1.0, 1.0]),
])
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Mesh::clear_instances

Remove all instances from a mesh (render defaults to 1 instance).

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::mesh::Mesh;
let mut m = Mesh::new();
m.clear_instances();
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Mesh } from "fragmentcolor";
const m = new Mesh();
m.clearInstances();
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Mesh
m = Mesh()
m.clear_instances()
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
