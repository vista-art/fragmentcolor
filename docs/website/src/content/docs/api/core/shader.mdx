---
title: Shader
description: "The [Shader](/api/core/shader) object is the main building block in [FragmentColor](https://fragmentcolor.org)."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

The [Shader](/api/core/shader) object is the main building block in [FragmentColor](https://fragmentcolor.org).

It takes a WGSL or GLSL shader source as input, parses it, validates it, and exposes the uniforms as keys.

To draw your shader, you must use your [Shader](/api/core/shader) instance as input to a [Renderer](/api/core/renderer).

You can compose [Shader](/api/core/shader) instances into a [Pass](/api/core/pass) object to create more complex rendering pipelines.

You can also create renderings with multiple Render Passes by using multiple [Pass](/api/core/pass) instances to a [Frame](/api/core/frame) object.



## Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 fn main() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Shader, Renderer};

let shader = Shader::new(r#"
    @vertex
    fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>, 3>(
            vec2<f32>(-1.0, -1.0),
            vec2<f32>( 3.0, -1.0),
            vec2<f32>(-1.0,  3.0)
        );
        return vec4<f32>(pos[vertex_index], 0.0, 1.0);
    }

    @group(0) @binding(0)
    var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red
    }
"#)?;

// Set the "resolution" uniform
shader.set("resolution", [800.0, 600.0])?;
let res: [f32; 2] = shader.get("resolution")?;

let renderer = Renderer::new();
let target = renderer.create_texture_target([16, 16])?;
renderer.render(&shader, &target)?;

 assert_eq!(res, [800.0, 600.0]);
 assert!(shader.list_uniforms().len() >= 1);
 Ok(())
 }
`}
lang="rust" meta="collapse={1-1, 33-36}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Shader, Renderer } from "fragmentcolor";

const shader = new Shader(\`
    @vertex
    fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>, 3>(
            vec2<f32>(-1.0, -1.0),
            vec2<f32>( 3.0, -1.0),
            vec2<f32>(-1.0,  3.0)
        );
        return vec4<f32>(pos[vertex_index], 0.0, 1.0);
    }

    @group(0) @binding(0)
    var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red
    }

\`);

// Set the "resolution" uniform;
shader.set("resolution", [800.0, 600.0]);
const res = shader.get("resolution");

const renderer = new Renderer();
const target = renderer.createTextureTarget([16, 16]);
renderer.render(shader, target);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Shader, Renderer

shader = Shader("""
    @vertex
    fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>, 3>(
            vec2<f32>(-1.0, -1.0),
            vec2<f32>( 3.0, -1.0),
            vec2<f32>(-1.0,  3.0)
        );
        return vec4<f32>(pos[vertex_index], 0.0, 1.0);
    }

    @group(0) @binding(0)
    var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red
    }

""")

 # Set the "resolution" uniform
shader.set("resolution", [800.0, 600.0])
res = shader.get("resolution")

renderer = Renderer()
target = renderer.create_texture_target([16, 16])
renderer.render(shader, target)

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


## Methods


---

### Shader::new(source: string)

Creates a new [Shader](/api/core/shader) instance from the given WGSL source string, file path, or URL.

GLSL is also supported if you enable the `glsl` feature.
Shadertoy-flavored GLSL is supported if the `shadertoy` feature is enabled.

If the optional features are enabled, the constructor will try to automatically
detect the shader type and parse it accordingly.

If an exception occurs during parsing, the error message will indicate the location of the error.

If the initial source validation passes, the shader is guaranteed to work on the GPU. All uniforms are initialized to their default zero values.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 fn main() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::Shader;

let shader = Shader::new(r#"
    @vertex
    fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>, 3>(
            vec2<f32>(-1.0, -1.0),
            vec2<f32>( 3.0, -1.0),
            vec2<f32>(-1.0,  3.0)
        );
        return vec4<f32>(pos[vertex_index], 0.0, 1.0);
    }

    @group(0) @binding(0)
    var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red
    }
"#)?;

 assert!(shader.list_keys().len() >= 1);
 Ok(())
 }
`}
lang="rust" meta="collapse={1-1, 25-27}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Shader } from "fragmentcolor";

const shader = new Shader(\`
    @vertex
    fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>, 3>(
            vec2<f32>(-1.0, -1.0),
            vec2<f32>( 3.0, -1.0),
            vec2<f32>(-1.0,  3.0)
        );
        return vec4<f32>(pos[vertex_index], 0.0, 1.0);
    }

    @group(0) @binding(0)
    var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red
    }

\`);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Shader

shader = Shader("""
    @vertex
    fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>, 3>(
            vec2<f32>(-1.0, -1.0),
            vec2<f32>( 3.0, -1.0),
            vec2<f32>(-1.0,  3.0)
        );
        return vec4<f32>(pos[vertex_index], 0.0, 1.0);
    }

    @group(0) @binding(0)
    var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
        return vec4<f32>(1.0, 0.0, 0.0, 1.0); // Red
    }

""")

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Shader::set(key: string, value: any)

Sets the value of the uniform identified by the given key.

If the key does not exist or the value format is incorrect, the `set` method throws an exception. The shader remains valid, and if the exception is caught, the shader can still be used with the renderer.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 fn main() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::Shader;

let shader = Shader::default();
shader.set("resolution", [800.0, 600.0])?;
 Ok(())
 }
`}
lang="rust" meta="collapse={1-1, 6-7}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Shader } from "fragmentcolor";

const shader = Shader.default();
shader.set("resolution", [800.0, 600.0]);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Shader

shader = Shader.default()
shader.set("resolution", [800.0, 600.0])
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Shader::get(key: string) -&gt; any

Returns the current value of the uniform identified by the given key.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 fn main() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::Shader;

let shader = Shader::default();
shader.set("resolution", [800.0, 600.0])?;
let res: [f32; 2] = shader.get("resolution")?;

 assert_eq!(res, [800.0, 600.0]);
 Ok(())
 }
`}
lang="rust" meta="collapse={1-1, 8-10}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Shader } from "fragmentcolor";

const shader = Shader.default();
shader.set("resolution", [800.0, 600.0]);
const res = shader.get("resolution");

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Shader

shader = Shader.default()
shader.set("resolution", [800.0, 600.0])
res = shader.get("resolution")

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Shader::list_uniforms() -&gt; [string]

Returns a list of all uniform names in the [Shader](/api/core/shader) (excluding struct fields).

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 fn main() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::Shader;

let shader = Shader::default();
let list = shader.list_uniforms();

 assert!(list.contains(&"resolution".to_string()));
 Ok(())
 }
`}
lang="rust" meta="collapse={1-1, 7-9}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Shader } from "fragmentcolor";

const shader = Shader.default();
const list = shader.listUniforms();

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Shader

shader = Shader.default()
list = shader.list_uniforms()

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Shader::list_keys() -&gt; [string]

Returns a list of all keys in the [Shader](/api/core/shader), including uniform names and struct fields using the dot notation.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 fn main() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::Shader;

let shader = Shader::default();
let keys = shader.list_keys();

 assert!(keys.contains(&"resolution".to_string()));
 Ok(())
 }
`}
lang="rust" meta="collapse={1-1, 8-10}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Shader } from "fragmentcolor";

const shader = Shader.default();
const keys = shader.listKeys();

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Shader

shader = Shader.default()
keys = shader.list_keys()

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
