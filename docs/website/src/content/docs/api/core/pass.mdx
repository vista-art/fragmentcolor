---
title: Pass
description: "The [Pass](/api/core/pass) object is a collection of [Shader](/api/core/shader) objects that are rendered to a [Target](/api/core/target) by the [Renderer](/api/core/renderer)."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

The [Pass](/api/core/pass) object is a collection of [Shader](/api/core/shader) objects that are rendered to a [Target](/api/core/target) by the [Renderer](/api/core/renderer).

While the [Shader](/api/core/shader) represents a single **Render Pipeline** or a **Compute Pipeline**,
the [Pass](/api/core/pass) can be used to draw multiple Shaders in sequence,
for example when you have multiple objects in a scene with different materials.

The [Pass](/api/core/pass) represents a single RenderPass or a ComputePass in the WebGPU API.

The constructor creates a RenderPass by default. To create a ComputePass, call [Pass](/api/core/pass)::compute().

After creation, it will only accept a compatible [Shader](/api/core/shader) object. If you try to add a Compute [Shader](/api/core/shader) to a Render [Pass](/api/core/pass) or vice-versa,
it won't add the shader to its internal list and log a warning message in the console.



## Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{ Shader, Pass, Renderer, Frame };

let renderer = Renderer::new();
let window = fragmentcolor::headless_window([100, 100]);
let target = renderer.create_target(window).await?;
let shader = Shader::default();

let mut pass = Pass::new("First Pass");
pass.add_shader(&shader);

let mut pass2 = Pass::new("Second Pass");
pass2.add_shader(&shader);

// standalone
renderer.render(&pass, &target)?;

// using a Frame
let mut frame = Frame::new();
frame.add_pass(&pass);
frame.add_pass(&pass2);
renderer.render(&frame, &target)?;

// vector of passes (consume them)
renderer.render(&vec![pass, pass2], &target)?;

 Ok(())
 }
 fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 28-30}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Shader, Pass, Renderer, Frame } from "fragmentcolor";

const renderer = new Renderer();
const canvas = document.createElement('canvas');
const target = await renderer.createTarget(canvas);
const shader = Shader.default();

const pass = new Pass("First Pass");
pass.addShader(shader);

const pass2 = new Pass("Second Pass");
pass2.addShader(shader);

// standalone;
renderer.render(pass, target);

// using a Frame;
const frame = new Frame();
frame.addPass(pass);
frame.addPass(pass2);
renderer.render(frame, target);

// vector of passes (consume them);
renderer.render([pass, pass2], target);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from rendercanvas.auto import RenderCanvas, loop

from fragmentcolor import Shader, Pass, Renderer, Frame

renderer = Renderer()
canvas = RenderCanvas(size=(100, 100))
target = renderer.create_target(canvas)
shader = Shader.default()

rpass = Pass("First Pass")
rpass.add_shader(shader)

pass2 = Pass("Second Pass")
pass2.add_shader(shader)

# standalone
renderer.render(rpass, target)

# using a Frame
frame = Frame()
frame.add_pass(rpass)
frame.add_pass(pass2)
renderer.render(frame, target)

# vector of passes (consume them)
renderer.render([rpass, pass2], target)

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


## Methods


---

### Pass::new(name: &str) -&gt; Self

#### Creates a new Pass

The name property is optional and is used for debugging purposes.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::Pass;

let pass = Pass::new("first pass");

 let _ = pass;
`}
lang="rust" meta="collapse={5-5}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Pass } from "fragmentcolor";

const pass = new Pass("first pass");

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Pass

rpass = Pass("first rpass")

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Pass::from_shader(name: &str, shader: Shader) -&gt; Pass

Creates a new [Pass](/api/core/pass) from a single [Shader](/api/core/shader).

The created [Pass](/api/core/pass) inherits the render/compute type from the provided [Shader](/api/core/shader).

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Pass, Shader};

let shader = Shader::default();
let pass = Pass::from_shader("single", &shader);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Pass, Shader } from "fragmentcolor";

const shader = Shader.default();
const pass = new Pass("single"); pass.addShader(shader);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Pass, Shader

shader = Shader.default()
rpass = Pass("single"); rpass.add_shader(shader)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Pass::add_shader(shader: Shader)

Adds a [Shader](/api/core/shader) object to the [Pass](/api/core/pass).

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Pass, Shader};

let shader = Shader::default();
let pass = Pass::new("p");
pass.add_shader(&shader);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Pass, Shader } from "fragmentcolor";

const shader = Shader.default();
const pass = new Pass("p");
pass.addShader(shader);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Pass, Shader

shader = Shader.default()
rpass = Pass("p")
rpass.add_shader(shader)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Pass::set_clear_color(color: [f32; 4])

Sets the clear color for this [Pass](/api/core/pass).

When the pass is configured to clear, the render target is cleared to the given RGBA color before drawing.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
 async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Pass, Shader};

let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 64]).await?;

let shader = Shader::default();
let mut pass = Pass::new("solid background");
pass.add_shader(&shader);

pass.set_clear_color([0.1, 0.2, 0.3, 1.0]);

renderer.render(&pass, &target)?;

 Ok(())
 }
 fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 16-18}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Renderer, Pass, Shader } from "fragmentcolor";

const renderer = new Renderer();
const target = await renderer.createTextureTarget([64, 64]);

const shader = Shader.default();
const pass = new Pass("solid background");
pass.addShader(shader);

pass.setClearColor([0.1, 0.2, 0.3, 1.0]);

renderer.render(pass, target);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Renderer, Pass, Shader

renderer = Renderer()
target = renderer.create_texture_target([64, 64])

shader = Shader.default()
rpass = Pass("solid background")
rpass.add_shader(shader)

rpass.set_clear_color([0.1, 0.2, 0.3, 1.0])

renderer.render(rpass, target)

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
