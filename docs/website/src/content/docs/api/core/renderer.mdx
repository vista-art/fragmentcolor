---
title: Renderer
description: "The [Renderer](/api/core/renderer) is the main entry point for [FragmentColor](https://fragmentcolor.org) and normally the first object you create."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

The [Renderer](/api/core/renderer) is the main entry point for
[FragmentColor](https://fragmentcolor.org) and normally the first object you create.

It is used to render
[Shader](/api/core/shader)s,
[Pass](/api/core/pass)es, and
[Frame](/api/core/frame)s
to a [Target](/api/core/target) (canvas or window) or to a Bitmap.

The [Renderer](/api/core/renderer) internals are lazily initialized
when the user creates a [Target](/api/core/target) or renders a Bitmap.
This ensures the adapter and device are compatible with the target environment.

At the point of creation, we don't know if it will be used offscreen
or attached to a platform-specific Window or Canvas.

The API ensures the [Renderer](/api/core/renderer) is usable when `render()` is called,
because
the `render()` method expects a [Target](/api/core/target) as input. So, the user must call
`Renderer.create_target()` first, which initializes a window adapter, or
`Renderer.render_image()` which initializes an offscreen adapter.

## Example

```rust
use fragmentcolor::Renderer;
let _renderer = Renderer::new();
```

## Methods

### Renderer::new()

#### Creates a new Renderer

The [Renderer](/api/core/renderer) internals are lazily initialized
when the user creates a [Target](/api/core/target) or renders a Bitmap.
This ensures the adapter and device are compatible with the target environment.

At the point of creation, we don't know if it will be used offscreen or attached to a Window.

The API ensures the [Renderer](/api/core/renderer) is usable when `render()` is called,
because the `render()` method expects a [Target](/api/core/target) as input, and
the only way to create a [Target](/api/core/target)
is by calling `renderer.create_target(Window)` first.

- `Renderer.create_target()` internally initializes a window adapter, while
- `Renderer.render_image()` initializes an offscreen adapter.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::Renderer;
let renderer = Renderer::new();
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer } from "fragmentcolor";
const renderer = new Renderer();
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer
renderer = Renderer()
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### create_target(target: Canvas | Window)

Creates a [Target](/api/core/target) attached to a platform-specific canvas or window.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::Renderer;

// Platform-specific window binding (winit shown as an example)
// use winit::event_loop::EventLoop;
// use winit::window::WindowBuilder;
// fn main() -> Result<(), Box<dyn std::error::Error>> {
let renderer = Renderer::new();
// let event_loop = EventLoop::new()?;
// let window = WindowBuilder::new().build(&event_loop)?;
// let target = renderer.create_target(&window)?;
// Ok(())
// }
`}
lang="rust" meta="collapse={3-6, 8-12}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer } from "fragmentcolor";

// Platform-specific window binding (winit shown as an example)
// use winit::event_loop::EventLoop;
// use winit::window::WindowBuilder;
// fn main() -> Result<(), Box<dyn std::error::Error>> {
const renderer = new Renderer();
// let event_loop = EventLoop::new()?;
// let window = WindowBuilder::new().build(&event_loop)?;
// let target = renderer.create_target(&window)?;
// Ok(())
// }
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer

# Platform-specific window binding (winit shown as an example)
# use winit::event_loop::EventLoop;
# use winit::window::WindowBuilder;
# fn main() -> Result<(), Box<dyn std::error::Error>> {
renderer = Renderer()
# let event_loop = EventLoop::new()?;
# let window = WindowBuilder::new().build(&event_loop)?;
# let target = renderer.create_target(&window)?;
# Ok(())
# }
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### Headless rendering: create_texture_target

Render to an offscreen texture without a Window or Canvas.

This is useful for tests, server-side rendering, or running examples in CI.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Renderer, Shader};

async fn run() -> Result<(), Box<dyn std::error::Error>> {
let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 64]).await?;
let shader = Shader::default();
renderer.render(&shader, &target)?;
let _image = target.get_image();
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={3-3, 9-11}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer, Shader } from "fragmentcolor";

async fn run() -> Result<(), Box<dyn std::error::Error>> {;
const renderer = new Renderer();
let target = renderer.create_texture_target([64, 64]).await?;
const shader = exampleShader();
renderer.render(shader, target)?;
let _image = target.get_image();
Ok(());
};
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) };
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer, Shader

async fn run() -> Result<(), Box<dyn std::error::Error>> {
renderer = Renderer()
let target = renderer.create_texture_target([64, 64]).await?
shader = example_shader()
renderer.render(shader, target)?
let _image = target.get_image()
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### render(renderable: Shader | Pass | Frame, target: Target)

Renders the given object to the given [Target](/api/core/target).

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Renderer, Shader};

async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let target = renderer.create_texture_target([10, 10]).await?;
let shader = Shader::default();
renderer.render(&shader, &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={3-3, 10-12}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer, Shader } from "fragmentcolor";

async fn run() -> Result<(), Box<dyn std::error::Error>> {;

const renderer = new Renderer();
let target = renderer.create_texture_target([10, 10]).await?;
const shader = exampleShader();
renderer.render(shader, target)?;

Ok(());
};
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) };
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer, Shader

async fn run() -> Result<(), Box<dyn std::error::Error>> {

renderer = Renderer()
let target = renderer.create_texture_target([10, 10]).await?
shader = example_shader()
renderer.render(shader, target)?

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
