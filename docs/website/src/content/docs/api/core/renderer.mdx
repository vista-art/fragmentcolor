---
title: Renderer
description: "The [Renderer](/api/core/renderer) is the main entry point for [FragmentColor](https://fragmentcolor.org) and normally the first object you create."
category: core
categoryLabel: Core
---

## Description

The [Renderer](/api/core/renderer) is the main entry point for
[FragmentColor](https://fragmentcolor.org) and normally the first object you create.

It is used to render
[Shader](/api/core/shader)s,
[Pass](/api/core/pass)es, and
[Frame](/api/core/frame)s
to a [Target](/api/core/target) (canvas or window) or to a Bitmap.

The [Renderer](/api/core/renderer) internals are lazily initialized
when the user creates a [Target](/api/core/target) or renders a Bitmap.
This ensures the adapter and device are compatible with the target environment.

At the point of creation, we don't know if it will be used offscreen
or attached to a platform-specific Window or Canvas.

The API ensures the [Renderer](/api/core/renderer) is usable when `render()` is called,
because
the `render()` method expects a [Target](/api/core/target) as input. So, the user must call
`Renderer.create_target()` first, which initializes a window adapter, or
`Renderer.render_image()` which initializes an offscreen adapter.

## Example

```rust
use fragmentcolor::Renderer;
let renderer = Renderer::new();
```

## Methods

### Renderer::new()

#### Creates a new Renderer

The [Renderer](/api/core/renderer) internals are lazily initialized
when the user creates a [Target](/api/core/target) or renders a Bitmap.
This ensures the adapter and device are compatible with the target environment.

At the point of creation, we don't know if it will be used offscreen or attached to a Window.

The API ensures the [Renderer](/api/core/renderer) is usable when `render()` is called,
because the `render()` method expects a [Target](/api/core/target) as input, and
the only way to create a [Target](/api/core/target)
is by calling `renderer.create_target(Window)` first.

- `Renderer.create_target()` internally initializes a window adapter, while
- `Renderer.render_image()` initializes an offscreen adapter.

#### Example

```rust
use fragmentcolor::Renderer;
let renderer = Renderer::new();
```

### Python

```python
renderer = Renderer()
```

### Javascript

```js
const renderer = new Renderer();
```

### create_target(target: Canvas | Window)

Creates a [Target](/api/core/target) attached to a platform-specific canvas or window.

#### Example

##### Javascript (Web)

```js
import init, { Renderer } from "fragmentcolor";
await init();
const renderer = new Renderer();
const canvas = document.createElement("canvas");
const target = await renderer.createTarget(canvas);
```

##### Python

```python
from fragmentcolor import Renderer
from rendercanvas.auto import RenderCanvas

renderer = Renderer()
canvas = RenderCanvas()
target = renderer.create_target(canvas)
```

### Headless rendering: create_texture_target

Render to an offscreen texture without a Window or Canvas.

This is useful for tests, server-side rendering, or running examples in CI.

#### Example

##### Rust

```rust path=null start=null collapse={1-1, 3-3, 13-15}

async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Shader, Pass, Frame};
let renderer = Renderer::new();

let target = renderer.create_texture_target([64, 64]).await?;

let shader = Shader::default();
renderer.render(&shader, &target)?;

let image = target.get_image();

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

#### Python

```python path=null start=null
from fragmentcolor import Renderer, Shader, Pass, Frame

renderer = Renderer()
# size can be a tuple or list
target = renderer.create_texture_target((64, 64))

shader = Shader("circle.wgsl")
shader.set("resolution", [64.0, 64.0])
shader.set("circle.radius", 10.0)
shader.set("circle.color", [1.0, 0.0, 0.0, 0.8])
shader.set("circle.border", 2.0)
shader.set("circle.position", [0.0, 0.0])

renderer.render(shader, target)

img = target.get_image()
```

#### Javascript (Web)

```js path=null start=null
import init, { Renderer, Shader, Pass, Frame } from "fragmentcolor";

await init();

const renderer = new Renderer();
// size is an array [width, height]
const target = await renderer.createTextureTarget([64, 64]);

const shader = new Shader("circle.wgsl");
shader.set("resolution", [64.0, 64.0]);
shader.set("circle.radius", 10.0);
shader.set("circle.color", [1.0, 0.0, 0.0, 0.8]);
shader.set("circle.border", 2.0);
shader.set("circle.position", [0.0, 0.0]);

renderer.render(shader, target);

const img = target.getImage();
```

### Python

```python
target = renderer.create_texture_target((64, 64))
```

### Javascript

```js
const target = await renderer.createTextureTarget([64, 64]);
```

### render(renderable: Shader | Pass | Frame, target: Target)

Renders the given object to the given [Target](/api/core/target).

#### Example

```rust collapse={1-1, 3-3, 9-11}

async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Shader};
let renderer = Renderer::new();
let target = renderer.create_texture_target([10, 10]).await?;
let shader = Shader::default();
renderer.render(&shader, &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

### Python

```python
renderer.render(shader, target)
```

### Javascript

```js
renderer.render(shader, target);
```
