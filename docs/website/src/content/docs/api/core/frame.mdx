---
title: Frame
description: "The [Frame](/api/core/frame) object is a collection of [Pass](/api/core/pass) objects that are rendered to a [Target](/api/core/target) by the [Renderer](/api/core/renderer)."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

The [Frame](/api/core/frame) object is a collection of [Pass](/api/core/pass) objects that are rendered to a [Target](/api/core/target) by the [Renderer](/api/core/renderer).

It is used to render multiple passes to a single target, such as an opaque pass followed by a transparent pass.

You need to inject the [Frame](/api/core/frame) object into the [Renderer](/api/core/renderer) to render it.



## Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{ Shader, Pass, Renderer, Frame };

let renderer = Renderer::new();
let target = renderer.create_texture_target([100, 100]).await?;

let pass1 = Pass::new("first");
let pass2 = Pass::new("second");

let mut frame = Frame::new();
frame.add_pass(&pass1);
frame.add_pass(&pass2);

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 15-17}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Shader, Pass, Renderer, Frame } from "fragmentcolor";

const renderer = new Renderer();
const target = await renderer.createTextureTarget([100, 100]);

const pass1 = new Pass("first");
const pass2 = new Pass("second");

const frame = new Frame();
frame.addPass(pass1);
frame.addPass(pass2);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Shader, Pass, Renderer, Frame

renderer = Renderer()
target = renderer.create_texture_target([100, 100])

pass1 = Pass("first")
pass2 = Pass("second")

frame = Frame()
frame.add_pass(pass1)
frame.add_pass(pass2)

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


## Methods


---

### Frame::new()

Creates a new [Frame](/api/core/frame) object.

A [Frame](/api/core/frame) is an ordered collection of [Pass](/api/core/pass) objects that will be rendered by the [Renderer](/api/core/renderer) in sequence.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::Frame;

let frame = Frame::new();
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame } from "fragmentcolor";

const frame = new Frame();
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame

frame = Frame()
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Frame::add_pass(pass: Pass)

Adds a [Pass](/api/core/pass) to this [Frame](/api/core/frame).

Passes are rendered in the order they are added.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Frame, Pass};

let mut pass1 = Pass::new("first");
let mut pass2 = Pass::new("second");

let mut frame = Frame::new();
frame.add_pass(&pass1);
frame.add_pass(&pass2);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame, Pass } from "fragmentcolor";

const pass1 = new Pass("first");
const pass2 = new Pass("second");

const frame = new Frame();
frame.addPass(pass1);
frame.addPass(pass2);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame, Pass

pass1 = Pass("first")
pass2 = Pass("second")

frame = Frame()
frame.add_pass(pass1)
frame.add_pass(pass2)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Frame::connect(parent, child)

Creates a dependency relationship between two passes in the frame's execution graph.

#### Syntax

```rust
pub fn connect(
    &mut self,
    parent: &Pass,
    child: &Pass,
) -> Result<(), FrameError>
```

#### Parameters

- `parent` - The pass that must execute before the child pass
- `child` - The pass that depends on the parent pass completing first

#### Return Value

- `Ok(())` - The dependency was successfully established
- `Err(FrameError::MissingPass)` - One or both passes are not present in this frame
- `Err(FrameError::DuplicateEdge)` - This dependency relationship already exists

#### Description

The `connect` method establishes an execution dependency between two passes. When the frame is rendered, the parent pass will always execute before the child pass. This allows you to build complex rendering pipelines where later passes depend on the results of earlier passes.

The frame maintains a directed acyclic graph (DAG) of pass dependencies. Each edge in this graph represents a "happens-before" relationship between passes.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::{Frame, Pass};

let depth_pass = Pass::new("depth_prepass");
let lighting_pass = Pass::new("lighting");

let mut frame = Frame::new();
frame.add_pass(&depth_pass);
frame.add_pass(&lighting_pass);

// Ensure depth prepass runs before lighting
frame.connect(&depth_pass, &lighting_pass)?;
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
async fn run() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::{Frame, Pass};

let geometry_pass = Pass::new("geometry");
let shadow_pass = Pass::new("shadows");
let lighting_pass = Pass::new("lighting");
let post_process = Pass::new("post_processing");

let mut frame = Frame::new();

// Add all passes
frame.add_pass(&geometry_pass);
frame.add_pass(&shadow_pass);
frame.add_pass(&lighting_pass);
frame.add_pass(&post_process);

// Build dependency chain
frame.connect(&geometry_pass, &shadow_pass)?;
frame.connect(&shadow_pass, &lighting_pass)?;
frame.connect(&lighting_pass, &post_process)?;
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 13-16, 36-38}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame, Pass } from "fragmentcolor";

const depth_pass = new Pass("depth_prepass");
const lighting_pass = new Pass("lighting");

const frame = new Frame();
frame.addPass(depth_pass);
frame.addPass(lighting_pass);

// Ensure depth prepass runs before lighting;
frame.connect(depth_pass, lighting_pass);
import { Frame, Pass } from "fragmentcolor";

const geometry_pass = new Pass("geometry");
const shadow_pass = new Pass("shadows");
const lighting_pass = new Pass("lighting");
const post_process = new Pass("post_processing");

const frame = new Frame();

// Add all passes;
frame.addPass(geometry_pass);
frame.addPass(shadow_pass);
frame.addPass(lighting_pass);
frame.addPass(post_process);

// Build dependency chain;
frame.connect(geometry_pass, shadow_pass);
frame.connect(shadow_pass, lighting_pass);
frame.connect(lighting_pass, post_process);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame, Pass

depth_pass = Pass("depth_prepass")
lighting_pass = Pass("lighting")

frame = Frame()
frame.add_pass(depth_pass)
frame.add_pass(lighting_pass)

# Ensure depth prepass runs before lighting
frame.connect(depth_pass, lighting_pass)
from fragmentcolor import Frame, Pass

geometry_pass = Pass("geometry")
shadow_pass = Pass("shadows")
lighting_pass = Pass("lighting")
post_process = Pass("post_processing")

frame = Frame()

# Add all passes
frame.add_pass(geometry_pass)
frame.add_pass(shadow_pass)
frame.add_pass(lighting_pass)
frame.add_pass(post_process)

# Build dependency chain
frame.connect(geometry_pass, shadow_pass)
frame.connect(shadow_pass, lighting_pass)
frame.connect(lighting_pass, post_process)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Frame::present(pass)

Designates which render pass should present its output to the final target.

#### Syntax

```rust
pub fn present(&mut self, pass: &Pass) -> Result<(), FrameError>
```

#### Parameters

- `pass` - The render pass to designate for final presentation

#### Return Value

- `Ok(())` - The pass was successfully set as the present pass
- `Err(FrameError::MissingPass)` - The pass is not present in this frame
- `Err(FrameError::NotRenderPass)` - The pass is a compute pass (only render passes can present)
- `Err(FrameError::NotALeaf)` - Other passes depend on this pass (must be a leaf node)
- `Err(FrameError::InvalidPresentPass)` - A different pass is already designated for presentation

#### Description

The `present` method designates which render pass should output to the final render target (typically the screen or a final texture). This pass becomes the "output" of the entire frame.

##### Requirements

The present pass must satisfy several requirements:

1. **Must be a render pass** - Only render passes can present output; compute passes cannot
2. **Must be a leaf node** - No other passes can depend on the present pass
3. **Only one per frame** - Each frame can have at most one present pass

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::{Frame, Pass};

let shadow = Pass::new("shadow");
let main = Pass::new("main");

let mut frame = Frame::new();
frame.add_pass(&shadow);
frame.add_pass(&main);
frame.connect(&shadow, &main)?;

// Main pass is a leaf, so it can present
frame.present(&main)?;
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
async fn run() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::{Frame, Pass};

let geometry = Pass::new("geometry");
let lighting = Pass::new("lighting");
let post_fx = Pass::new("post_effects");

let mut frame = Frame::new();
frame.add_pass(&geometry);
frame.add_pass(&lighting);
frame.add_pass(&post_fx);

// Build pipeline
frame.connect(&geometry, &lighting)?;
frame.connect(&lighting, &post_fx)?;

// Final post-effects pass presents to screen
frame.present(&post_fx)?;
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 14-17, 35-37}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame, Pass } from "fragmentcolor";

const shadow = new Pass("shadow");
const main = new Pass("main");

const frame = new Frame();
frame.addPass(shadow);
frame.addPass(main);
frame.connect(shadow, main);

// Main pass is a leaf, so it can present;
frame.present(main);
import { Frame, Pass } from "fragmentcolor";

const geometry = new Pass("geometry");
const lighting = new Pass("lighting");
const post_fx = new Pass("post_effects");

const frame = new Frame();
frame.addPass(geometry);
frame.addPass(lighting);
frame.addPass(post_fx);

// Build pipeline;
frame.connect(geometry, lighting);
frame.connect(lighting, post_fx);

// Final post-effects pass presents to screen;
frame.present(post_fx);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame, Pass

shadow = Pass("shadow")
main = Pass("main")

frame = Frame()
frame.add_pass(shadow)
frame.add_pass(main)
frame.connect(shadow, main)

# Main pass is a leaf, so it can present
frame.present(main)
from fragmentcolor import Frame, Pass

geometry = Pass("geometry")
lighting = Pass("lighting")
post_fx = Pass("post_effects")

frame = Frame()
frame.add_pass(geometry)
frame.add_pass(lighting)
frame.add_pass(post_fx)

# Build pipeline
frame.connect(geometry, lighting)
frame.connect(lighting, post_fx)

# Final post-effects pass presents to screen
frame.present(post_fx)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
