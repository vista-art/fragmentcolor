---
title: Frame
description: "The [Frame](/api/core/frame) object is a collection of [Pass](/api/core/pass) objects that are rendered to a [Target](/api/core/target) by the [Renderer](/api/core/renderer)."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

The [Frame](/api/core/frame) object is a collection of [Pass](/api/core/pass) objects that are rendered to a [Target](/api/core/target) by the [Renderer](/api/core/renderer).

It is used to render multiple passes to a single target, such as an opaque pass followed by a transparent pass.

You need to inject the [Frame](/api/core/frame) object into the [Renderer](/api/core/renderer) to render it.



## Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{ Shader, Pass, Renderer, Frame };

let renderer = Renderer::new();
let target = renderer.create_texture_target([100, 100]).await?;

let pass1 = Pass::new("first");
let pass2 = Pass::new("second");

let mut frame = Frame::new();
frame.add_pass(&pass1);
frame.add_pass(&pass2);

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 15-17}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Shader, Pass, Renderer, Frame } from "fragmentcolor";

const renderer = new Renderer();
const target = await renderer.createTextureTarget([100, 100]);

const pass1 = new Pass("first");
const pass2 = new Pass("second");

const frame = new Frame();
frame.addPass(pass1);
frame.addPass(pass2);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Shader, Pass, Renderer, Frame

renderer = Renderer()
target = renderer.create_texture_target([100, 100])

pass1 = Pass("first")
pass2 = Pass("second")

frame = Frame()
frame.add_pass(pass1)
frame.add_pass(pass2)

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


## Methods


---

### Frame::new()

Creates a new [Frame](/api/core/frame) object.

A [Frame](/api/core/frame) is an ordered collection of [Pass](/api/core/pass) objects that will be rendered by the [Renderer](/api/core/renderer) in sequence.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::Frame;

let frame = Frame::new();
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame } from "fragmentcolor";

const frame = new Frame();
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame

frame = Frame()
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Frame::add_pass(pass: Pass)

Adds a [Pass](/api/core/pass) to this [Frame](/api/core/frame).

Passes are rendered in the order they are added.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Frame, Pass};

let mut pass1 = Pass::new("first");
let mut pass2 = Pass::new("second");

let mut frame = Frame::new();
frame.add_pass(&pass1);
frame.add_pass(&pass2);
`}
lang="rust"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame, Pass } from "fragmentcolor";

const pass1 = new Pass("first");
const pass2 = new Pass("second");

const frame = new Frame();
frame.addPass(pass1);
frame.addPass(pass2);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame, Pass

pass1 = Pass("first")
pass2 = Pass("second")

frame = Frame()
frame.add_pass(pass1)
frame.add_pass(pass2)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>


---

### Frame::present(pass)

Designates which render pass should present its output to the final target.

#### Syntax

```rust
pub fn present(&mut self, pass: &Pass) -> Result<(), FrameError>
```

#### Parameters

- `pass` - The render pass to designate for final presentation

#### Return Value

- `Ok(())` - The pass was successfully set as the present pass
- `Err(FrameError::MissingPass)` - The pass is not present in this frame
- `Err(FrameError::NotRenderPass)` - The pass is a compute pass (only render passes can present)
- `Err(FrameError::NotALeaf)` - Other passes depend on this pass (must be a leaf node)
- `Err(FrameError::InvalidPresentPass)` - A different pass is already designated for presentation

#### Description

The `present` method designates which render pass should output to the final render target (typically the screen or a final texture). This pass becomes the "output" of the entire frame.

##### Requirements

The present pass must satisfy several requirements:

1. **Must be a render pass** - Only render passes can present output; compute passes cannot
2. **Must be a leaf node** - No other passes can depend on the present pass
3. **Only one per frame** - Each frame can have at most one present pass

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::{Frame, Pass};

let shadow = Pass::new("shadow");
let main = Pass::new("main");

let mut frame = Frame::new();
frame.add_pass(&shadow);
frame.add_pass(&main);
main.require(&shadow)?;

// Main pass can present
frame.present(&main)?;
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
async fn run() -> Result<(), Box<dyn std::error::Error>> {
use fragmentcolor::{Frame, Pass};

let geometry = Pass::new("geometry");
let lighting = Pass::new("lighting");
let post_fx = Pass::new("post_effects");

let mut frame = Frame::new();
frame.add_pass(&geometry);
frame.add_pass(&lighting);
frame.add_pass(&post_fx);

// Build pipeline using Pass::require
lighting.require(&geometry)?;
post_fx.require(&lighting)?;

// Final post-effects pass presents to screen
frame.present(&post_fx)?;
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 14-17, 35-37}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Frame, Pass } from "fragmentcolor";

const shadow = new Pass("shadow");
const main = new Pass("main");

const frame = new Frame();
frame.addPass(shadow);
frame.addPass(main);
main.require(shadow);

// Main pass can present;
frame.present(main);
import { Frame, Pass } from "fragmentcolor";

const geometry = new Pass("geometry");
const lighting = new Pass("lighting");
const post_fx = new Pass("post_effects");

const frame = new Frame();
frame.addPass(geometry);
frame.addPass(lighting);
frame.addPass(post_fx);

// Build pipeline using Pass.require;
lighting.require(geometry);
post_fx.require(lighting);

// Final post-effects pass presents to screen;
frame.present(post_fx);
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Frame, Pass

shadow = Pass("shadow")
main = Pass("main")

frame = Frame()
frame.add_pass(shadow)
frame.add_pass(main)
main.require(shadow)

# Main pass can present
frame.present(main)
from fragmentcolor import Frame, Pass

geometry = Pass("geometry")
lighting = Pass("lighting")
post_fx = Pass("post_effects")

frame = Frame()
frame.add_pass(geometry)
frame.add_pass(lighting)
frame.add_pass(post_fx)

# Build pipeline using Pass.require
lighting.require(geometry)
post_fx.require(lighting)

# Final post-effects pass presents to screen
frame.present(post_fx)
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder: bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
