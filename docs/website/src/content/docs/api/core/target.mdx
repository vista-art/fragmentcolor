---
title: Target
description: "The [Target](/api/core/target) interface (trait in Rust) is a rendering destination for the [Renderer](/api/core/renderer) implemented by both [WindowTarget](/api/targets/windowtarget) and [TextureTarget](/api/targets/texturetarget)."
category: core
categoryLabel: Core
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

The [Target](/api/core/target) interface (trait in Rust) is a rendering destination for the [Renderer](/api/core/renderer) implemented by both [WindowTarget](/api/targets/windowtarget) and [TextureTarget](/api/targets/texturetarget).

It contains a GPU surface texture attached to a platform-specific window or an offscreen texture for headless rendering (see [TextureTarget](/api/targets/texturetarget)).

[Target](/api/core/target) constructors are private and can only be created via the [Renderer](/api/core/renderer) using either `Renderer.create_target(window)` for on-screen rendering, or `Renderer.create_texture_target()` for offscreen rendering.

## Examples

### WindowTarget (on-screen)

```rust,no_run collapse={2-2, 10-12}
use fragmentcolor::{Renderer, Shader};
async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let window = fragmentcolor::mock_window([800, 600]);
let target = renderer.create_target(window).await?;
let shader = Shader::default();
renderer.render(&shader, &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

### TextureTarget (offscreen)

```rust collapse={2-2, 10-12}
use fragmentcolor::{Renderer, Shader, Target};
async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 64]).await?;
let shader = Shader::default();
renderer.render(&shader, &target)?;
let image = target.get_image();

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

## Methods

### get_current_frame() -&gt; TargetFrame

Returns a frame wrapper containing the texture view to render and the target format.

Most users do not need to call this directly; the [Renderer](/api/core/renderer) uses it internally.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Renderer, Target};

async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let target = renderer.create_texture_target([16, 16]).await?;
let frame = target.get_current_frame()?; // Acquire a frame
let _format = frame.format();

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={3-3, 10-12}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer, Target } from "fragmentcolor";

async fn run() -> Result<(), Box<dyn std::error::Error>> {;

const renderer = new Renderer();
let target = renderer.create_texture_target([16, 16]).await?;
let frame = target.get_current_frame()?; // Acquire a frame;
let _format = frame.format();

Ok(());
};
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) };
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer, Target

async fn run() -> Result<(), Box<dyn std::error::Error>> {

renderer = Renderer()
let target = renderer.create_texture_target([16, 16]).await?
let frame = target.get_current_frame()? // Acquire a frame
let _format = frame.format()

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### get_image() -&gt; Vec&lt;u8&gt;

Returns the current contents of the target as a byte array in RGBA8 format.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Renderer, Target};

fn main() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let target = pollster::block_on(renderer.create_texture_target([16, 16]))?;
renderer.render(&fragmentcolor::Shader::default(), &target)?;

let image = target.get_image();
Ok(())
}
`}
lang="rust" meta="collapse={3-3, 10-11}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer, Target } from "fragmentcolor";

fn main() -> Result<(), Box<dyn std::error::Error>> {;

const renderer = new Renderer();
let target = pollster::block_on(renderer.create_texture_target([16, 16]))?;
renderer.render(fragmentcolor::Shader::default(), target)?;

let image = target.get_image();
Ok(());
};
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer, Target

fn main() -> Result<(), Box<dyn std::error::Error>> {

renderer = Renderer()
let target = pollster::block_on(renderer.create_texture_target([16, 16]))?
renderer.render(fragmentcolor::Shader::default(), target)?

let image = target.get_image()
Ok(())
}
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### resize(size: [u32; 2] | (u32, u32))

Resizes the [Target](/api/core/target) to the given width and height.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Renderer, Target};

async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let mut target = renderer.create_texture_target([64, 32]).await?;

let size: [u32; 2] = target.size().into();
assert_eq!(size, [64, 32]);

target.resize([128, 64]);
let size: [u32; 2] = target.size().into();
assert_eq!(size, [128, 64]);

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={3-3, 15-17}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer, Target } from "fragmentcolor";

async fn run() -> Result<(), Box<dyn std::error::Error>> {;

const renderer = new Renderer();
let mut target = renderer.create_texture_target([64, 32]).await?;

let size: [u32; 2] = target.size().into();
assert_eq!(size, [64, 32]);

target.resize([128, 64]);
let size: [u32; 2] = target.size().into();
assert_eq!(size, [128, 64]);

Ok(());
};
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) };
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer, Target

async fn run() -> Result<(), Box<dyn std::error::Error>> {

renderer = Renderer()
let mut target = renderer.create_texture_target([64, 32]).await?

let size: [u32 2] = target.size().into()
assert_eq!(size, [64, 32])

target.resize([128, 64])
let size: [u32 2] = target.size().into()
assert_eq!(size, [128, 64])

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### size() -&gt; [u32; 2]

Returns the size of the [Target](/api/core/target) in pixels.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::{Renderer, Target};

async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 32]).await?;
let size: [u32; 2] = target.size().into();
assert_eq!(size, [64, 32]);

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={3-3, 10-12}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer, Target } from "fragmentcolor";

async fn run() -> Result<(), Box<dyn std::error::Error>> {;

const renderer = new Renderer();
let target = renderer.create_texture_target([64, 32]).await?;
let size: [u32; 2] = target.size().into();
assert_eq!(size, [64, 32]);

Ok(());
};
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) };
`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer, Target

async fn run() -> Result<(), Box<dyn std::error::Error>> {

renderer = Renderer()
let target = renderer.create_texture_target([64, 32]).await?
let size: [u32 2] = target.size().into()
assert_eq!(size, [64, 32])

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
