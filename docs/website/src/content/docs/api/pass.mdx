---
title: Pass
description: "The [Pass](https://fragmentcolor.org/api/pass) object is a collection of [Shader](https://fragmentcolor.org/api/shader) objects that are rendered to a [Target](https://fragmentcolor.org/api/target) by the [Renderer](https://fragmentcolor.org/api/renderer)."
---

## Description

The [Pass](https://fragmentcolor.org/api/pass) object is a collection of [Shader](https://fragmentcolor.org/api/shader) objects that are rendered to a [Target](https://fragmentcolor.org/api/target) by the [Renderer](https://fragmentcolor.org/api/renderer).

While the [Shader](https://fragmentcolor.org/api/shader) represents a single **Render Pipeline** or a **Compute Pipeline**,
the [Pass](https://fragmentcolor.org/api/pass) can be used to draw multiple Shaders in sequence,
for example when you have multiple objects in a scene with different materials.

The [Pass](https://fragmentcolor.org/api/pass) represents a single RenderPass or a ComputePass in the WebGPU API.

The constructor creates a RenderPass by default. To create a ComputePass, call [Pass](https://fragmentcolor.org/api/pass)::compute().

After creation, it will only accept a compatible [Shader](https://fragmentcolor.org/api/shader) object. If you try to add a Compute [Shader](https://fragmentcolor.org/api/shader) to a Render [Pass](https://fragmentcolor.org/api/pass) or vice-versa,
it won't add the shader to its internal list and log a warning message in the console.

## Example

```rust collapse={2-2, 4-4, 22-24}

async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{ Shader, Pass, Renderer };
let renderer = Renderer::new();
let target = renderer.create_texture_target([10, 10]).await?;
let object1 = Shader::default();
let object2 = Shader::default();

let mut pass = Pass::new("First Pass");
pass.add_shader(&object1);
pass.add_shader(&object2);

renderer.render(&pass, &target)?;

let mut pass2 = Pass::new("Second Pass");
pass2.add_shader(&object1);
pass2.add_shader(&object2);

renderer.render(&vec![pass, pass2], &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

## Methods

### Pass::new(name: &str) -&gt; Self

#### Creates a new Pass

The name property is optional and is used for debugging purposes.

#### Example

```rust
use fragmentcolor::Pass;

let _pass = Pass::new("first pass");
```

### Python

```python
rpass = Pass("single pass")
```

### Javascript

```js
const rpass = new Pass("single pass");
```

### compute(name: &str) -&gt; Pass

Creates a new [Pass](https://fragmentcolor.org/api/pass) configured for compute workloads.

Only [Shader](https://fragmentcolor.org/api/shader) objects that compile to compute pipelines can be added.

#### Example

```rust
use fragmentcolor::Pass;

let pass = Pass::compute("compute pass");
// Add compute shaders once available
```

### from_shader(name: &str, shader: Shader) -&gt; Pass

Creates a new [Pass](https://fragmentcolor.org/api/pass) from a single [Shader](https://fragmentcolor.org/api/shader).

The created [Pass](https://fragmentcolor.org/api/pass) inherits the render/compute type from the provided [Shader](https://fragmentcolor.org/api/shader).

#### Example

```rust
use fragmentcolor::{Pass, Shader};

let shader = Shader::default();
let pass = Pass::from_shader("single", &shader);
```

### load_previous()

Configures this [Pass](https://fragmentcolor.org/api/pass) to load the previous contents of the [Target](https://fragmentcolor.org/api/target) instead of clearing it.

This is useful when layering multiple passes where the next pass should blend with the prior results.

#### Example

```rust collapse={2-2, 4-4, 15-17}

async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Pass, Shader};
let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 64]).await?;

let shader = Shader::default();
let mut pass = Pass::new("blend with previous");
pass.add_shader(&shader);
pass.load_previous();

renderer.render(&pass, &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

### get_input() -&gt; PassInput

Returns a copy of the current input configuration for this [Pass](https://fragmentcolor.org/api/pass).

It includes the clear/load behavior and clear color.

#### Example

```rust
use fragmentcolor::Pass;

let pass = Pass::new("example");
let _input = pass.get_input();
// Inspect fields via dedicated APIs; internal fields are not public
```

### add_shader(shader: Shader)

Adds a [Shader](https://fragmentcolor.org/api/shader) object to the [Pass](https://fragmentcolor.org/api/pass).

#### Example

```rust
use fragmentcolor::{Pass, Shader};

let shader = Shader::default();
let pass = Pass::new("p");
pass.add_shader(&shader);
```

### Python

```python
rpass.add_shader(shader)
```

### Javascript

```js
rpass.add_shader(shader);
```

### set_viewport(viewport: Region)

Sets the viewport region for this [Pass](https://fragmentcolor.org/api/pass).

The viewport restricts drawing to a rectangular area of the [Target](https://fragmentcolor.org/api/target).

#### Example

```rust collapse={2-2, 4-4, 16-18}

async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Pass, Shader, Region};
let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 64]).await?;

let shader = Shader::default();
let mut pass = Pass::new("clipped");
pass.add_shader(&shader);

pass.set_viewport(Region::from_region(0, 0, 32, 32));

renderer.render(&pass, &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

### set_clear_color(color: [f32; 4])

Sets the clear color for this [Pass](https://fragmentcolor.org/api/pass).

When the pass is configured to clear, the render target is cleared to the given RGBA color before drawing.

#### Example

```rust collapse={2-2, 4-4, 16-18}

async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Pass, Shader};
let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 64]).await?;

let shader = Shader::default();
let mut pass = Pass::new("solid background");
pass.add_shader(&shader);

pass.set_clear_color([0.1, 0.2, 0.3, 1.0]);

renderer.render(&pass, &target)?;

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```
