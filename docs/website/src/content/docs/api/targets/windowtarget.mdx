---
title: WindowTarget
description: "[WindowTarget](/api/targets/windowtarget) is an implementation of [Target](/api/core/target) that represents a rendering destination attached to a platform-specific window."
category: targets
categoryLabel: Targets
---

import { Code, Tabs, TabItem, Aside } from "@astrojs/starlight/components";

## Description

[WindowTarget](/api/targets/windowtarget) is an implementation of [Target](/api/core/target) that represents a rendering destination attached to a platform-specific window.

The [Target](/api/core/target) object is a rendering destination for the [Renderer](/api/core/renderer).

It contains a GPU surface texture attached to a platform-specific window or an offscreen texture for headless rendering (see [TextureTarget](/api/targets/texturetarget)).

## Example

```no-run
# async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Shader};

// Platform-specific window, e.g. winit, glfw, sdl2, etc.
// We have official support for winit but other libraries can be used
// if you implement the required traits. See the source code for details.
let window = fragmentcolor::mock_window([800, 600]);

let renderer = Renderer::new();
let target = renderer.create_target(window).await?;

renderer.render(&Shader::default(), &target)?;

# Ok(())
# }
# fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
```

## Methods

### get_current_frame() -&gt; TargetFrame

Returns a frame wrapper containing the texture view to render and the target format.

Most users do not need to call this directly; the [Renderer](/api/core/renderer) uses it internally.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
use fragmentcolor::Renderer;

async fn run() -> Result<(), Box<dyn std::error::Error>> {

let renderer = Renderer::new();
let target = renderer.create_texture_target([16, 16]).await?;
let frame = target.get_current_frame()?; // Acquire a frame
let _format = frame.format();

Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={3-3, 10-12}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`
import { Renderer } from "fragmentcolor";


const renderer = new Renderer();
const target = await renderer.createTextureTarget([16, 16]);
const frame = target.getCurrentFrame()?; // Acquire a frame;
const _format = frame.format();

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`
from fragmentcolor import Renderer


renderer = Renderer()
target = renderer.create_texture_target([16, 16])
frame = target.get_current_frame(); // Acquire a frame
_format = frame.format()

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### get_image()

This operation returns an empty array for [WindowTarget](/api/targets/windowtarget).

Use a [TextureTarget](/api/targets/texturetarget) instead.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::Renderer;

let renderer = Renderer::new();
let target = renderer.create_texture_target([16, 16]).await?;
renderer.render(&fragmentcolor::Shader::default(), &target)?;

let image = target.get_image();

assert_eq!(image.len(), 16 * 16 * 4); // RGBA8
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 11-14}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Renderer } from "fragmentcolor";

const renderer = new Renderer();
const target = await renderer.createTextureTarget([16, 16]);
renderer.render(fragmentcolor.Shader.default(), target)?;

const image = target.getImage();

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Renderer

renderer = Renderer()
target = renderer.create_texture_target([16, 16])
renderer.render(fragmentcolor.Shader.default(), target)

image = target.get_image()

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### resize(size: [u32; 2] | (u32, u32))

Resizes the [Target](https://fragmentcolor.org/docs/api/target) to the given width and height.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::Renderer;

let renderer = Renderer::new();
let mut target = renderer.create_texture_target([64, 32]).await?;

target.resize([128, 64]);

assert_eq!(target.size(), [128, 64]);
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 10-13}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Renderer } from "fragmentcolor";

const renderer = new Renderer();
const target = await renderer.createTextureTarget([64, 32]);

target.resize([128, 64]);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Renderer

renderer = Renderer()
target = renderer.create_texture_target([64, 32])

target.resize([128, 64])

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>

### size() -&gt; [u32; 2]

Returns the size of the [Target](/api/core/target) in pixels.

#### Example

<Tabs>

<TabItem label="Rust">
<Code
code={`
async fn run() -> Result<(), Box<dyn std::error::Error>> {

use fragmentcolor::{Renderer, Shader};

let renderer = Renderer::new();
let target = renderer.create_texture_target([64, 32]).await?;

assert_eq!(target.size(), [64, 32]);
Ok(())
}
fn main() -> Result<(), Box<dyn std::error::Error>> { pollster::block_on(run()) }
`}
lang="rust" meta="collapse={1-1, 8-11}"
/>

</TabItem>

<TabItem label="JavaScript">
<Code
code={`

import { Renderer, Shader } from "fragmentcolor";

const renderer = new Renderer();
const target = await renderer.createTextureTarget([64, 32]);

`}
lang="js"
/>

</TabItem>

<TabItem label="Python">
<Code
code={`

from fragmentcolor import Renderer, Shader

renderer = Renderer()
target = renderer.create_texture_target([64, 32])

`}
lang="python"
/>

</TabItem>

<TabItem label="Swift">
<Aside type="caution" title="Work in progress">Swift bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Swift placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

<TabItem label="Kotlin">
<Aside type="caution" title="Work in progress">Kotlin/Android bindings are not yet available; implementation is in the works.</Aside>
<Code
code={`
// Kotlin placeholder â bindings WIP

`}
lang="text"
/>

</TabItem>

</Tabs>
