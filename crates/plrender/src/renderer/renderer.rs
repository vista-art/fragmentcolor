use crate::{
    app::window::IsWindow,
    renderer::{
        options::{DEVICE_LIMITS, POWER_PREFERENCE},
        target::{RenderTargetCollection, Target, TargetId, Targets, WindowTarget},
        RenderOptions, RenderPass,
    },
    resources::{
        mesh::{MeshData, MeshId},
        texture::{Texture, TextureId},
        Resources,
    },
    scene::Scene,
    Window,
};
use std::sync::{Arc, RwLock, RwLockReadGuard, RwLockWriteGuard};
use winit::window::WindowId;

pub type Commands = Vec<wgpu::CommandBuffer>;

type Error = Box<dyn std::error::Error>;
type WindowSurface = (WindowId, wgpu::Extent3d, wgpu::Surface);
type WindowSurfaces = Vec<WindowSurface>;

pub trait RenderContext {
    fn resources(&self) -> Arc<RwLock<Resources>>;
    fn read_resources(&self) -> RwLockReadGuard<Resources>;
    fn write_resources(&self) -> RwLockWriteGuard<Resources>;
    fn targets(&self) -> Arc<RwLock<Targets>>;
    fn read_targets(&self) -> RwLockReadGuard<Targets>;
    fn write_targets(&self) -> RwLockWriteGuard<Targets>;
    fn device(&self) -> &wgpu::Device;
    fn queue(&self) -> &wgpu::Queue;
}

// @TODO describe the renderer
/// ðŸŽ¨ Draws things on the screen or on a texture
///
/// The Renderer is the link between the CPU world and the GPU world.
///
/// Full Description TBD
#[derive(Debug)]
pub struct Renderer {
    pub(crate) instance: wgpu::Instance,
    pub(crate) adapter: wgpu::Adapter,
    pub(crate) device: wgpu::Device,
    pub(crate) queue: wgpu::Queue,
    pub(crate) pass: String, // @TODO support multiple render passes
    pub(crate) targets: Arc<RwLock<Targets>>,
    pub(crate) resources: Arc<RwLock<Resources>>,
}

impl RenderContext for Renderer {
    fn resources(&self) -> Arc<RwLock<Resources>> {
        self.resources.clone()
    }
    fn read_resources(&self) -> RwLockReadGuard<Resources> {
        self.resources
            .try_read()
            .expect("Could not get resources mutex lock")
    }
    fn write_resources(&self) -> RwLockWriteGuard<Resources> {
        self.resources
            .try_write()
            .expect("Could not get resources mutex lock")
    }
    fn targets(&self) -> Arc<RwLock<Targets>> {
        self.targets.clone()
    }
    fn read_targets(&self) -> RwLockReadGuard<Targets> {
        self.targets
            .try_read()
            .expect("Could not get targets mutex lock")
    }
    fn write_targets(&self) -> RwLockWriteGuard<Targets> {
        self.targets
            .try_write()
            .expect("Could not get targets mutex lock")
    }
    fn device(&self) -> &wgpu::Device {
        &self.device
    }
    fn queue(&self) -> &wgpu::Queue {
        &self.queue
    }
}

impl Renderer {
    pub async fn new_offscreen(options: RenderOptions) -> Result<Renderer, Error> {
        Renderer::new::<Window>(options, vec![]).await
    }

    pub async fn new<'w, W: IsWindow>(
        options: RenderOptions,
        windows: Vec<&'w mut W>,
    ) -> Result<Renderer, Error> {
        if crate::app::RENDERER.get().is_some() {
            return Err("Renderer already initialized".into());
        }

        let pass = options.render_pass.clone();
        let (instance, adapter, device, queue, targets) =
            Internal::gpu_objects(options, windows).await?;
        let targets = Arc::new(RwLock::new(targets));
        let resources = Arc::new(RwLock::new(Resources::new()));

        Ok(Renderer {
            instance,
            adapter,
            device,
            queue,
            pass,
            targets,
            resources,
        })
    }

    /// Registers a loaded mesh to the Resources Manager.
    ///
    /// This function takes a MeshData instance generated by the MeshBuilder
    /// after it uploads the raw mesh vertex and index buffers to the GPU.
    pub fn add_mesh(&self, mesh: MeshData) -> MeshId {
        self.write_resources().add_mesh(mesh)
    }

    /// Removes a mesh from the Resources Manager.
    pub fn remove_mesh(&self, id: &MeshId) -> Option<MeshData> {
        self.write_resources().remove_mesh(id)
    }

    /// Registers a loaded texture to the Resources Manager.
    ///
    /// The texture is already loaded into the GPU at this point.
    pub fn add_texture(&self, texture: Texture) -> TextureId {
        self.write_resources().add_texture(texture)
    }

    /// Removes a texture from the Resources Manager.
    pub fn remove_texture(&self, id: &TextureId) -> Option<Texture> {
        self.write_resources().remove_texture(id)
    }

    /// Registers an OS Window or a Web Canvas element as a rendering target.
    ///
    /// This method expects the Window to implement the `IsWindow` trait,
    /// which allows the renderer to assign a unique Target ID to it.
    pub async fn add_target<W: IsWindow>(&self, window: W) -> Result<TargetId, Error> {
        let surface = Internal::surface(&self.instance, &window)?;
        let target = Internal::target(&self.device, &self.adapter, surface);
        Ok(self.write_targets().add(target))
    }

    /// Removes a rendering target from the renderer.
    pub fn remove_target(&self, id: &TargetId) -> Option<Target> {
        self.write_targets().remove(id)
    }

    /// Where the magic starts! ðŸª„
    ///
    /// Selects a RenderPass to render a frame from the given Scene
    pub fn render(&self, scene: &Scene) -> Result<(), wgpu::SurfaceError> {
        if self.pass == "solid" {
            return self.solid_renderpass(scene);
        }
        self.flat_renderpass(scene)
    }

    // Renders the Flat 2D render pass (for sprites and shapes)
    fn flat_renderpass(&self, scene: &Scene) -> Result<(), wgpu::SurfaceError> {
        let renderpass = crate::renderer::renderpass::Flat2D::new(self);

        self.draw(scene, renderpass)
    }

    // Renders the Solid 3D render pass
    fn solid_renderpass(&self, scene: &Scene) -> Result<(), wgpu::SurfaceError> {
        let renderpass = crate::renderer::renderpass::Solid::new(
            &crate::renderer::renderpass::SolidConfig {
                cull_back_faces: true,
            },
            self,
        );

        self.draw(scene, renderpass)
    }

    // Where the magic happens! ðŸŽ¨
    //
    // Renders a frame from the given Scene with the given RenderPass
    fn draw<P: RenderPass>(
        &self,
        scene: &Scene,
        mut renderpass: P,
    ) -> Result<(), wgpu::SurfaceError> {
        // Records the render commands in the GPU command buffer
        let (commands, frames) = renderpass.draw(scene.read_state())?;

        // Runs the commands (submit to GPU queue)
        self.queue.submit(commands);

        // Shows the rendered frames on the screen
        let mut targets = self.write_targets();
        targets.present(frames);

        Ok(())
    }
}

// Helper static methods
struct Internal;
impl Internal {
    async fn gpu_objects<'w, W: IsWindow>(
        options: RenderOptions,
        windows: Vec<&'w mut W>,
    ) -> Result<
        (
            wgpu::Instance,
            wgpu::Adapter,
            wgpu::Device,
            wgpu::Queue,
            Targets,
        ),
        Error,
    > {
        let instance = wgpu::Instance::new(wgpu::InstanceDescriptor::default());
        let (power_preference, force_fallback_adapter, limits) = Internal::parse_options(options);
        let surfaces = Internal::surfaces(&instance, &windows);

        let adapter = instance
            .request_adapter(&wgpu::RequestAdapterOptions {
                power_preference,
                force_fallback_adapter,
                compatible_surface: surfaces.first().map(|(_, _, surface)| surface),
            })
            .await
            .ok_or("Failed to find an appropriate GPU adapter")?;

        let (device, queue) = adapter
            .request_device(
                &wgpu::DeviceDescriptor {
                    features: wgpu::Features::empty(),
                    limits,
                    label: None,
                },
                None, // Trace path
            )
            .await?;

        let targets = Internal::targets(&device, &adapter, surfaces);

        Ok((instance, adapter, device, queue, targets))
    }

    fn parse_options(options: RenderOptions) -> (wgpu::PowerPreference, bool, wgpu::Limits) {
        let preference = options.power_preference;
        let limits = options.device_limits;
        let power_preference = POWER_PREFERENCE
            .get(&preference)
            .unwrap_or(&wgpu::PowerPreference::default())
            .to_owned();
        let device_limits = DEVICE_LIMITS
            .get(&limits)
            .unwrap_or(&wgpu::Limits::default())
            .to_owned();
        let force_fallback_adapter = options.force_software_rendering;

        (power_preference, force_fallback_adapter, device_limits)
    }

    fn surfaces<'w, W: IsWindow>(
        instance: &wgpu::Instance,
        window_list: &Vec<&'w mut W>,
    ) -> WindowSurfaces {
        window_list
            .into_iter()
            .filter_map(|window| {
                let surface = Self::surface(instance, *window).ok()?;
                Some(surface)
            })
            .collect()
    }

    fn surface<'w, W: IsWindow>(
        instance: &wgpu::Instance,
        window: &'w W,
    ) -> Result<WindowSurface, Error> {
        let surface = unsafe { instance.create_surface(window) }?;
        let size = window.size().to_wgpu_size();
        let id = window.id();
        Ok((id, size, surface))
    }

    fn targets(
        device: &wgpu::Device,
        adapter: &wgpu::Adapter,
        surfaces: WindowSurfaces,
    ) -> Targets {
        let mut targets = Targets::new();
        for surface in surfaces.into_iter() {
            let target = Internal::target(device, adapter, surface);
            targets.add(target);
        }

        targets
    }

    fn target(device: &wgpu::Device, adapter: &wgpu::Adapter, surface: WindowSurface) -> Target {
        let (id, size, surface) = surface;

        let surface_capabilities = surface.get_capabilities(&adapter);

        // The shader code assumes an sRGB surface texture. Using a different one
        // will result all the colors coming out darker. If you want to support non
        // sRGB surfaces, you'll need to account for that when drawing to the frame.
        let format = surface_capabilities
            .formats
            .iter()
            .copied()
            .find(|f| f.is_srgb())
            .unwrap_or(surface_capabilities.formats[0]);

        // alpha_mode should be transparent if the surface supports it
        let alpha_mode = surface_capabilities
            .alpha_modes
            .iter()
            .find(|m| *m == &wgpu::CompositeAlphaMode::PreMultiplied)
            .unwrap_or(&wgpu::CompositeAlphaMode::Auto)
            .to_owned();

        let config = wgpu::SurfaceConfiguration {
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            format,
            width: size.width,
            height: size.height,
            alpha_mode,
            present_mode: surface_capabilities.present_modes[0],
            view_formats: vec![],
        };

        surface.configure(&device, &config);

        Target::Window(WindowTarget {
            id,
            surface,
            config,
        })
    }
}
